syntax = "proto3";

package scheduler.scheduler_proto;
option go_package = "github.com/mennanov/scalemate/scheduler/scheduler_proto";

import "google/protobuf/empty.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "github.com/gogo/protobuf/gogoproto/gogo.proto";

service Scheduler {
    // CreateContainer creates a new Container entity in the service.
    // It will later be scheduled to an available Node to run.
    // Use ReceiveContainerUpdates() method to receive updates on a newly created Container.
    rpc CreateContainer (ContainerWithResourceRequest) returns (ContainerWithResourceRequest) {
    }
    // GetContainer gets a user owned Container.
    rpc GetContainer (ContainerLookupRequest) returns (Container) {
    }
    // ListContainers lists user owned Containers.
    rpc ListContainers (ListContainersRequest) returns (ListContainersResponse) {
    }
    // StopContainer stops and deletes a running Container on a Node.
    // A Container can't be restarted once it is stopped and deleted, a new one has to be created.
    // The method fails if the Container is not running.
    rpc StopContainer (ContainerLookupRequest) returns (google.protobuf.Empty) {
    }
    // ReceiveUpdates streams real time updates of a Container and its ResourceRequests.
    // The most recent version of the Container is always returned as the first response with all the fields filled in.
    // All the existing Container ResourceRequests are also returned immediately.
    // Subsequent responses will only contain fields that were actually updated.
    rpc ReceiveContainerUpdates (ContainerLookupRequest) returns (stream ContainerUpdate) {
    }
    // AddResourceRequest adds a new resources limit request to be applied to a Container.
    // LXD limits can be updated dynamically even when a Container is running.
    // This method fails immediately if the Node can't provide the resources requested.
    // Once created the limit has to be confirmed by the Node, this may take some time.
    // Use ReceiveContainerUpdates() to be notified about the status of the newly created Resource Requests.
    rpc AddResourceRequest (AddResourceRequestRequest) returns (ResourceRequest) {
    }
    // GetResourceRequest gets a ResourceRequest by ID.
    rpc GetResourceRequest (ResourceRequestLookupRequest) returns (ResourceRequest) {
    }
    // ListResourceRequests lists all Container ResourceRequests.
    rpc ListResourceRequests (ListResourceRequestsRequest) returns (ListResourceRequestsResponse) {
    }
    // GetNode gets the Node details.
    rpc GetNode (NodeLookupRequest) returns (Node) {
    }
    // ListNodes lists Nodes that satisfy the given criteria.
    rpc ListNodes (ListNodesRequest) returns (ListNodesResponse) {
    }
    // ListNodeLabels lists aggregated labels of the Nodes that are currently online.
    rpc ListNodeLabels (google.protobuf.Empty) returns (ListNodeLabelsResponse) {
    }
}

enum CPUClass {
    CPU_CLASS_UNKNOWN = 0;
    CPU_CLASS_ENTRY = 10;
    CPU_CLASS_INTERMEDIATE = 20;
    CPU_CLASS_ADVANCED = 30;
    CPU_CLASS_PRO = 40;
}

enum GPUClass {
    GPU_CLASS_UNKNOWN = 0;
    GPU_CLASS_ENTRY = 10;
    GPU_CLASS_INTERMEDIATE = 20;
    GPU_CLASS_ADVANCED = 30;
    GPU_CLASS_PRO = 40;
}

enum DiskClass {
    DISK_CLASS_UNKNOWN = 0;
    DISK_CLASS_HDD = 10;
    DISK_CLASS_SSD = 20;
}

// Container represents an LXC container on a Node.
message Container {
    // Readonly.
    int64 id = 1;
    google.protobuf.Int64Value node_id = 2 [(gogoproto.wktpointer) = true];
    google.protobuf.Int64Value node_pricing_id = 24 [(gogoproto.wktpointer) = true];
    string username = 3;

    enum Status {
        // Default status value.
        NEW = 0;
        // Container has been assigned to run on a specific Node and the corresponding resources have been allocated.
        SCHEDULED = 1;
        // Container is being preparing to be created on the Node: (root FS image is downloading, etc...).
        PREPARING = 2;
        // Container is running on the Node. While a Container is RUNNING it is billable.
        RUNNING = 3;
        // Container is stopped and removed from the Node.
        STOPPED = 4;
        // Container failed to start (invalid image, etc...).
        FAILED = 5;
        // The Node this Container is running on is offline (not connected to the service).
        // The Container may still be running and reachable over the network.
        // If the Node reconnects within 1 hour and the Container is running normally then it will have the RUNNING
        // status, OFFLINE_FAILED otherwise.
        // The time the Container is OFFLINE is not billable.
        OFFLINE = 6;
        // The Container was OFFLINE for 1 hour. It is then considered failed as unreachable.
        OFFLINE_FAILED = 7;
        // The Container is stopped due to insufficient funds.
        EVICTED = 8;
    }
    // Readonly.
    Status status = 4;
    // Readonly.
    string status_message = 5;

    // Public LXD image. See https://us.images.linuxcontainers.org for the full list.
    string image = 6;

    // Network incoming traffic minimum required speed in Mbit/sec.
    uint32 network_ingress_min = 7;
    // Network outgoing traffic minimum required speed in Mbit/sec.
    uint32 network_egress_min = 8;

    // Hardware requirements range.
    CPUClass cpu_class_min = 13;
    CPUClass cpu_class_max = 14;
    GPUClass gpu_class_min = 15;
    GPUClass gpu_class_max = 16;
    DiskClass disk_class_min = 17;
    DiskClass disk_class_max = 18;

    // Readonly.
    google.protobuf.Timestamp created_at = 19 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
    // Readonly.
    google.protobuf.Timestamp updated_at = 20 [(gogoproto.stdtime) = true];

    // Scheduling constraint labels (regexp supported).
    // The Container will only be scheduled to the Node which labels match these labels.
    repeated string labels = 21;
    // Auth token to communicate with the Node a Container is running on.
    // Readonly.
    bytes node_auth_token = 22;

    // When multiple Nodes are available for scheduling of this Container the Node is chosen according to the strategy.
    // Multiple strategies can be chained to achieve sorting by multiple criteria.
    // This field is only taken into consideration when the newly created Container can be scheduled immediately.
    // Otherwise the Container will be scheduled to the first available Node.
    repeated SchedulingStrategy scheduling_strategy = 23;
    // Max price limit per hour (in $1e-9).
    int64 max_price_limit = 25;
}

message SchedulingStrategy {
    enum Strategy {
        CHEAPEST = 0;
        MOST_RELIABLE = 1;
        LEAST_BUSY = 2;
    }
    Strategy strategy = 1;
    // Max difference in values (scores) to group Nodes by. Nodes with similar scores will be put in the same
    // bucket. Valid value range is [0, 100].
    uint32 difference_percentage = 2;
}

// Container resources limit request.
message ResourceRequest {
    // Readonly.
    int64 id = 1;
    // Readonly.
    int64 container_id = 2;

    // Number of CPUs to expose to the container.
    uint32 cpu = 3;
    // Memory limit in MB.
    uint32 memory = 4;
    // Disk (rootfs) limit in MB.
    uint32 disk = 5;
    // Number of GPUs to expose to the container.
    uint32 gpu = 6;

    enum Status {
        // Limits are requested to be applied to the container.
        REQUESTED = 0;
        // Limits are confirmed and applied to the container.
        CONFIRMED = 1;
        // Limits are declined (not enough resources, etc...).
        DECLINED = 2;
    }
    Status status = 9;
    // Error message for the DECLINED status.
    string status_message = 10;

    // Readonly fields.
    google.protobuf.Timestamp created_at = 11 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
    google.protobuf.Timestamp updated_at = 12 [(gogoproto.stdtime) = true];
}

message ReceiveContainerResourceRequestUpdatesRequest {
    int64 resource_request_id = 1;
}

// Node represents a physical machine that runs Containers.
message Node {
    int64 id = 1;
    string username = 2;
    string name = 3;

    enum Status {
        // Node is offline and is not able to run Containers.
        OFFLINE = 0;
        // Indicates that the Node is online and ready to run Containers.
        ONLINE = 1;
        // Node is gracefully shutting down: it's waiting for all the Containers to be stopped by the owners and is not
        // accepting new Containers.
        SHUTTING_DOWN = 2;
    }
    Status status = 4;

    // The number of CPUs the node has.
    uint32 cpu_capacity = 5;
    // The number of CPUs available for scheduling.
    uint32 cpu_available = 6;
    CPUClass cpu_class = 7;

    // Node's RAM capacity in Megabytes available for scheduling.
    uint32 memory_capacity = 8;
    // Node's RAM in Megabytes available for scheduling.
    uint32 memory_available = 9;

    // The number of GPU devices the Node has.
    uint32 gpu_capacity = 10;
    // The number of GPU devices available for scheduling.
    uint32 gpu_available = 11;
    GPUClass gpu_class = 12;

    // Node's disk capacity in Megabytes available for scheduling.
    uint32 disk_capacity = 13;
    // Node's disk in Megabytes available for scheduling.
    uint32 disk_available = 14;
    DiskClass disk_class = 15;
    // Node's max incoming traffic speed in Mbit/sec.
    uint32 network_ingress_capacity = 16;
    // Node's max outgoing traffic speed in Mbit/sec.
    uint32 network_egress_capacity = 17;

    // Node owner's defined labels for this Node.
    // These are also automatically populated with the Node's hardware model strings when it connects.
    repeated string labels = 18;

    // Number of Containers that have finished successfully (no failures).
    uint32 containers_succeeded = 19;
    // Number of Containers that failed on this Node when the Node was at fault.
    uint32 containers_failed = 20;
    // Total number of scheduled Containers on this Node, also includes currently running containers.
    // containers_scheduled = containers_succeeded + containers_failed + containers_running.
    uint32 containers_scheduled = 28;

    // The most recent connection time.
    google.protobuf.Timestamp connected_at = 21 [(gogoproto.stdtime) = true];
    // The most recent disconnect time.
    google.protobuf.Timestamp disconnected_at = 22 [(gogoproto.stdtime) = true];

    // Time this Node was initially registered.
    google.protobuf.Timestamp created_at = 24 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
    google.protobuf.Timestamp updated_at = 25 [(gogoproto.stdtime) = true];

    // Public IPv4 address.
    bytes ip = 26;
    bytes fingerprint = 27;
}

// Node pricing policy.
message NodePricing {
    // Readonly.
    int64 id = 1;

    int64 node_id = 2;

    // Price per 1 CPU unit/hour in $1e-9.
    uint64 cpu_price = 28;
    // Price per 1 MB/hour in $1e-9.
    uint64 memory_price = 29;
    // Price per 1 GPU unit/hour in $1e-9.
    uint64 gpu_price = 30;
    // Price per 1 MB/hour in $1e-9.
    uint64 disk_price = 31;

    // Readonly.
    google.protobuf.Timestamp created_at = 11 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
}

message NodeLookupRequest {
    int64 node_id = 1;
}

message ListNodesRequest {
    repeated Node.Status status = 1;

    enum Ordering {
        CONNECTED_AT_DESC = 0;
        CONNECTED_AT_ASC = 1;
        DISCONNECTED_AT_DESC = 2;
        DISCONNECTED_AT_ASC = 3;
        SCHEDULED_AT_DESC = 4;
        SCHEDULED_AT_ASC = 5;
    }
    // CONNECTED_AT_DESC is used by default.
    Ordering ordering = 2;

    // Limit of 50 is used by default.
    uint32 limit = 3;
    uint32 offset = 4;

    // Matches Nodes with cpu_available >= given value.
    float cpu_available = 5;
    // Matches Nodes with cpu_class_min <= given value <= cpu_class.
    CPUClass cpu_class = 6;

    // Matches Nodes with memory_available >= given value.
    uint32 memory_available = 7;

    // Matches Nodes with gpu_available >= given value.
    uint32 gpu_available = 8;
    // Matches Nodes with gpu_class_min <= given value <= gpu_class.
    GPUClass gpu_class = 9;

    // Matches Nodes with disk_available >= given value.
    uint32 disk_available = 10;
    // Matches Nodes with disk_class_min <= given value <= disk_class.
    DiskClass disk_class = 11;

    // Matches Nodes with these labels (non-empty intersection).
    repeated string labels = 12;
    // Matches Nodes with containers_finished >= given value.
    uint32 containers_finished = 13;
    // Matches Nodes with containers_failed <= given value.
    uint32 containers_failed = 14;
}

message ListNodesResponse {
    repeated Node nodes = 1;
    // Total count of Nodes that match the corresponding ListNodesRequest without limit or offset applied.
    uint32 total_count = 2;
}

message ListNodeLabelsResponse {
    message Label {
        string label = 1;
        // Number of Nodes with this label.
        uint32 nodes_count = 2;
    }
    repeated Label labels = 1;
}


message ContainerWithResourceRequest {
    Container container = 1;
    ResourceRequest resource_request = 2;
}

message ContainerLookupRequest {
    int64 container_id = 1;
}

message ContainerUpdate {
    message ContainerData {
        Container container = 1;
        google.protobuf.FieldMask updated_fields = 2;
    }
    message ResourceRequestData {
        ResourceRequest resource_request = 1;
        google.protobuf.FieldMask updated_fields = 2;
    }
    oneof data {
        ContainerData container_data = 1;
        ResourceRequestData resource_request_data = 2;
        // Keepalive ping. Disregard messages of this type.
        bool ping = 3;
    }
}

message ListResourceRequestsRequest {
    int64 container_id = 1;
    repeated ResourceRequest.Status status = 2;

    enum Ordering {
        CREATED_AT_DESC = 0;
        CREATED_AT_ASC = 1;
        UPDATED_AT_DESC = 2;
        UPDATED_AT_ASC = 3;
    }
    // CREATED_AT_DESC is used by default.
    Ordering ordering = 3;

    // Limit of 50 is used by default.
    uint32 limit = 4;
    uint32 offset = 5;
}

message ListResourceRequestsResponse {
    repeated ResourceRequest resource_request = 1;
    uint32 total_count = 2;
}

message AddResourceRequestRequest {
    int64 container_id = 1;
    ResourceRequest resource_request = 2;
    google.protobuf.FieldMask updated_fields = 3;
}

message ListContainersRequest {
    string username = 1;
    repeated Container.Status status = 2;

    enum Ordering {
        CREATED_AT_DESC = 0;
        CREATED_AT_ASC = 1;
        UPDATED_AT_DESC = 2;
        UPDATED_AT_ASC = 3;
    }
    // CREATED_AT_DESC is used by default.
    Ordering ordering = 3;

    // Limit of 50 is used by default.
    uint32 limit = 4;
    uint32 offset = 5;
}

message ListContainersResponse {
    repeated Container containers = 1;
    // Total count of Containers that match the corresponding ListContainersRequest without limit or offset applied.
    uint32 total_count = 2;
}

message ResourceRequestLookupRequest {
    int64 container_id = 1;
}

message ContainerCreatedEvent {
    Container container = 1;
    ResourceRequest resource_request = 2;
}

message ContainerScheduledEvent {
    scheduler.scheduler_proto.Container container = 1;
    google.protobuf.FieldMask container_mask = 2;
    // The Node this Container is scheduled to.
    Node node = 3;
    google.protobuf.FieldMask node_mask = 4;
}

message ResourceRequestCreated {
    ResourceRequest resource_request = 1;
}

message ResourceRequestStatusChanged {
    ResourceRequest resource_request = 1;
}

message NodePricingCreatedEvent {
    NodePricing node_pricing = 1;
}

message NodeCreatedEvent {
    Node node = 1;
    NodePricing node_pricing = 2;
}